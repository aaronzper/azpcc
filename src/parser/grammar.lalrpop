use std::str::FromStr;

use crate::ast::*;
use crate::ast::types::*;
use crate::ast::declaration::*;
use crate::parser::{parse_if, parse_while};

use lalrpop_util::ParseError;

grammar;

match {
    r"([A-Za-z_][A-Za-z0-9_]*)" => Identifier,
    r"\d*" => IntLiteral,
    r#"'(?:\\(?:[abfnrtv\\'"]|x[0-9A-Fa-f]+|[0-7]{1,3})|[^\\'])'"# => CharLiteral,
    _
}

pub TransalationUnit: TranslationUnit = {
    <TopLevelDecl*> => TranslationUnit { 
        declarations: <>.into_boxed_slice()
    }
}

TopLevelDecl: Declaration = {
  <FunctionDecl> => <>,
  <Decl> => <>,
}

FunctionDecl: Declaration = {
  <FnDeclOpening> ";" => Declaration {
    name: <>.0,
    type_of: <>.1,
    value: None,
  },

  <o:FnDeclOpening> <b:StatementList> => Declaration {
    name: o.0,
    type_of: o.1,
    value: Some(DeclarationValue::Function(b)),
  }
}

#[inline]
FnDeclOpening: (String, Type) = {
  <r:FnTypeSpecifier> <n:Identifier> "(" <args:Comma<FnArg>> ")" => {
    let arg_types: Box<[Type]> = args.into_iter().map(|x| x.0).collect();
    let fn_type = Type::Function(Box::new(FunctionType {
      return_type: r,
      args: arg_types,
    }));

    (String::from(n), fn_type)
  }
}

#[inline]
FnTypeSpecifier: Option<Type> = {
  "void" => None,
  <TypeSpecifier> => Some(<>)
}

FnArg: (Type, String) = {
  <t:TypeSpecifier> <i:Identifier> => (t, String::from(i))
}

Decl: Declaration = {
  <t:TypeSpecifier> <n:Identifier> ";" => Declaration {
    name: String::from(n),
    type_of: t,
    value: None,
  },

  <t:TypeSpecifier> <n:Identifier> "=" <e:Expression> ";" => Declaration {
    name: String::from(n),
    type_of: t,
    value: Some(DeclarationValue::Variable(e)),
  },
}

Expression: Expression = {
  <IntLiteral> => Expression::IntLiteral(u64::from_str(<>).unwrap()),
  <CharLiteral> =>? 
    Err(ParseError::User { error: "Char literals not supported yet :(" }),
}

TypeSpecifier: Type = {
  <TypeSpecifier> "*" => Type::Pointer(Box::new(<>)),

  "signed" <InnerTypeSpecifier> =>? match <> {
    Type::Uint8 => Ok(Type::Int8),
    Type::Uint16 => Ok(Type::Int16),
    Type::Uint32 => Ok(Type::Int32),
    Type::Uint64 => Ok(Type::Int64),

    Type::Int8 => Ok(Type::Int8),
    Type::Int16 => Ok(Type::Int16),
    Type::Int32 => Ok(Type::Int32),
    Type::Int64 => Ok(Type::Int64),

    other => 
      Err(ParseError::User { error: "'signed' must preceede an integer type" })
  },

  "unsigned" <InnerTypeSpecifier> =>? match <> {
    Type::Int8 => Ok(Type::Uint8),
    Type::Int16 => Ok(Type::Uint16),
    Type::Int32 => Ok(Type::Uint32),
    Type::Int64 => Ok(Type::Uint64),

    Type::Uint8 => Ok(Type::Uint8),
    Type::Uint16 => Ok(Type::Uint16),
    Type::Uint32 => Ok(Type::Uint32),
    Type::Uint64 => Ok(Type::Uint64),

    other =>
      Err(ParseError::User { error: "'unsigned' must preceede an integer type" })
  },

  <InnerTypeSpecifier> => <>
}

InnerTypeSpecifier: Type = {
  "char" => Type::Int8,
  "short" => Type::Int16,
  "int" => Type::Int32,
  "long" => Type::Int64,
  "float" => Type::Float,
  "double" => Type::Double,
}

StatementList: Box<[Statement]> = {
  "{" <Statement*> "}" => <>.into_boxed_slice(),
}

Statement: Statement = {
  <OpenStmt> => <>,
  <ClosedStmt> => <>,
}

OpenStmt: Statement = {
  "if" "(" <c:Expression> ")" <i:Statement> => parse_if(c, i, None),
  "if" "(" <c:Expression> ")" <i:ClosedStmt> "else" <e:OpenStmt> =>
    parse_if(c, i, Some(e)),
  "while" "(" <c:Expression> ")" <b:OpenStmt> => parse_while(c, b),
}

ClosedStmt: Statement = {
  <OtherStmt> => <>,
  "if" "(" <c:Expression> ")" <i:ClosedStmt> "else" <e:ClosedStmt> =>
    parse_if(c, i, Some(e)),
  "while" "(" <c:Expression> ")" <b:ClosedStmt> => parse_while(c, b),
}

OtherStmt: Statement = {
  <StatementList> => Statement::Compound(<>),
  <Expression> ";" => Statement::Expression(Box::new(<>)),
  "return" <Expression> ";" => Statement::Return(Box::new(<>)),
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
